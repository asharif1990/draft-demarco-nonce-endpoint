---
title: "OAuth 2.0 Nonce Endpoint"
abbrev: "Nonce Endpoint"
category: info

docname: draft-demarco-nonce-endpoint-latest
submissiontype: IETF  # also: "independent", "editorial", "IAB", or "IRTF"
number:
date:
consensus: true
v: 3
# area: "Security"
# workgroup: OAuth 2.0 Working Group
keyword:
 - OAuth 2.0
venue:
#  group: WG
#  type: Working Group
#  mail: demarcog83@gmail.com
  github: "peppelinux/draft-demarco-nonce-endpoint"
  latest: "https://peppelinux.github.io/draft-demarco-nonce-endpoint/draft-demarco-nonce-endpoint.html"

author:
 -
    fullname: Giuseppe De Marco
    organization: Independent
    email: demarcog83@gmail.com

normative:
  RFC2119: RFC2119
  RFC5246: RFC5246
  RFC6749: RFC6749
  RFC7159: RFC7159
  RFC7519: RFC7519

informative:
  BCP195: BCP195

--- abstract
This document defines the nonce endpoint for OAuth 2.0 implementations [RFC6749]. It details how a server generates and issues opaque nonces and how a client can learn about this endpoint to obtain a nonce generated by the server.

--- middle

# Introduction

This specification presents a comprehensive guide to the nonce endpoint in OAuth 2.0 implementations [RFC6749]. It provides a detailed explanation of how a client can request and receive a server-generated nonce, which is a unique, arbitrary string used only once. The document further elaborates on the cryptographic mechanisms used in issuing nonces, ensuring the confidentiality of the information they carry. This document is intended to be a valuable resource for developers and system architects working with OAuth 2.0 and seeking to enhance their system's scalability, security and efficiency.

# Conventions and Definitions

{::boilerplate bcp14-tagged}

# Terminology

Nonce:
:  A random or pseudo-random number that is generated for a specific use, typically for cryptographic communication. The Nonce is used to protect against replay attacks by ensuring that a message or data cannot be reused or retransmitted. The term "nonce" stands for "number used once" and it MUST be unique within some scope.

Nonce Issuer:
:  The entity that generates and provides the Nonce. In the context of OAuth 2.0, the Nonce Issuer would typically be the Authorization Server.

Nonce Endpoint:
:  The HTTP endpoint provided by the Nonce Issuer for the issuance of the Nonces.

# Requirements

The Nonce Endpoint satisfies the following requirements:

- It MUST be secured by TLS [RFC5246];
- It MUST generate a Nonce in response to each request, such that under no circumstances can two identical nonces be generated by the Nonce Issuer in response to two different requests, whether these occur simultaneously or at different times.

The Nonce value satisfies the following requirements:

- It MUST be purely opaque to the Clients that receive these;
- It MUST be encrypted with an encryption key that:
  - MUST NOT be provided by the Nonce Issuer to the Client;
  - MUST NOT be provided by the Nonce Issuer to any other entity outside the domain where the Nonce Issuer belongs.

The Nonce Issuer satisfies the following requirements:

- The Nonce Issuer, and the servers within the Nonce Issuer's domain, can decrypt the Nonce and access its decrypted contents. No other entity might decrypt or know the decrypted contents of the Nonce.


# Nonce Request

When a Client needs a Nonce, it sends an HTTP GET request to the Nonce Endpoint.

Below is a non normative example of the HTTP Request made by a Client to the Nonce Endpoint.

~~~~ http
GET /nonce HTTP/1.1
Host: server.example.com
~~~~

# Nonce Response

The Nonce Endpoint provides a Nonce to the Client, encapsulated within a JSON object [RFC7159].
The response MUST use the HTTP Header Content-Type value set to `application/json` and MUST provide in the response message a JSON object with the member `nonce`.

Below is a non-normative example of the response given by a Nonce Endpoint:

~~~~ http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "nonce": "d2JhY2NhbG91cmVqdWFuZGFt"
}
~~~~

# Nonce Endpoint Discovery

When a server requires the use of a Nonce in the request for a specific resource and the Client doesn't provide it in its request,
the server MUST return an HTTP response with the  HTTP status code `400` and an `error` field with the value set to `"nonce_required"`.

This response MUST also contain the `Nonce-Endpoint-URI` HTTP header, with the value set to the URL corresponding to the Nonce Endpoint, where the Client SHOULD request and fetch a new Nonce.

The Client SHOULD use the endpoint provided in the `Nonce-Endpoint-URI` HTTP header to request a Nonce. Once the Nonce is received, the Client MAY renew the request to the server, including the obtained Nonce.

Below is a non-normative example of an error response issued by a server that requires the Nonce in the Client request, the response informs the Client about the Nonce Endpoint where the Nonce should be requested:

~~~~ http
HTTP/1.1 400 Bad Request
Nonce-Endpoint-URI: http://server.example.org/nonce-endpoint

{
  "error": "nonce_required",
  "error_description":
    "Authorization server requires the nonce in the request"
}
~~~~

In cases where, for some reasons, a correctly issued Nonce can no longer be considered valid by the server that receives it, the server MUST return the generic error `"nonce_required"` reporting the same description as `"error_description"`, as if the Nonce had not been received. The cases when an issued Nonce is considered no longer valid MAY be caused by the rotation of the encryption keys, its expiration or other specific conditions internal to an implementation.

# Non-normative Examples

The decrypted Nonce payload may use different formats and encodings, according to the different implemententative requirements, and contains any kind of implementation-specific attributes, such as the issuance time, the time of expiration, the audiences and other where needed.

Below are provided some non-normative examples, describing how a decrypted and JSON serialized Nonce payload may appear:

~~~~
{
  "iss": "https://issuer.example.com",
  "iat": 1615908701,
  "exp": 1615995101,
  "source_endpoint": "https://issuer.example.com/nonce-endpoint",
  "aud": [
    "https://service.example.com/endpoint",
    "https://another.example.com/cb"
  ]
}
~~~~

Please note that the values represented in the previous examples may depend on domain specific requirements and MUST NOT be intended as normative.

# Security Considerations

The Nonce Endpoint MUST be protected by TLS to prevent eavesdropping and man-in-the-middle attacks, therefore the practices defined in [BCP195] should be followed.

The Nonce Issuer MUST securely generate and store the encryption key used to encrypt the Nonce. The robustness of the encryption key plays a crucial role in the security of the Nonce Endpoint. The following considerations should be taken into account:

1. **Key Strength**: The cryptographic key used for encrypting the Nonce should be of sufficient length to resist brute-force attacks. For example, a key length of 256 bits is currently considered to provide a good level of security.

2. **Key Management**: The cryptographic key should be securely managed. It should be securely generated, stored, and revoked. Access to the key should be strictly controlled and limited to authorized entities only.

3. **Key Rotation**: Regular key rotation is a good practice to mitigate the risk of key compromise. The frequency of key rotation depends on the specific requirements and threat model, but a common practice is to rotate keys frequently.

4. **Randomness**: The cryptographic key, when used, should be generated using a secure random number generator to ensure its randomness. Predictable keys can be easily guessed by attackers.

5. **Secure Transmission**: If the cryptographic key needs to be transmitted over a network and within the Nonce Issuer domain, it must be securely transmitted using secure protocols such as TLS.

6. **Backup and Recovery**: Secure backup and recovery procedures should be in place for the cryptographic keys. This is to ensure that the key can be recovered in case of loss, while preventing unauthorized access to the backup.

The security of the Nonce Endpoint is only as strong as the security of the encryption key. Therefore, proper key management practices are essential.

# Considerations about nonce vs. jti

In this section are provided some consideration about the main differences and scopes about the nonce in comparison to the `jti` claim defined in [RFC7519].

Both `jti` and Nonces are used to prevents replay attacks, however Nonces offer more implementation flexibility and are considered best practice. They can be created and managed stateless (e.g., by issuing the hmac over the current time as the nonce), as this document outlines. 

The main differences between the use of the `jti` and the Nonces can be summarized as follows:

1. **Generation**: Nonces are generated by the server, while `jti` is generated by the Client.

2. **Storage**: Nonces can be self-authenticating and self-contained and therefore need not be stored. A common way to achieve this is for the Nonce to contain content encrypted to the server that creates it. On the other hand, checking `jti` properly definitely requires a store that is shared across all regions the token can be presented in.

3. **Lifetime**: The lifetime of a Nonce is usually shorter than that of a `jti`. A Nonce only needs to be remembered until the Client sends its response, which will be almost immediately after fetching the Nonce, therefore the lifetime of the Nonces is very short in comparison to the lifetime of the `jti`. By contrast, a `jti` will need to be remembered until the end of the expiration window of the JWT where it belongs to, which is much longer than the lifetime of a Nonce.

4. **Security**: Nonces prevent replay attacks by ensuring that the proof of possession is fresh. On the other hand, `jti` does not guarantee freshness and using client-generated timestamps has problems, even for non-attacking clients (e.g. devices with incorrect time-zones or daylight saving settings).

# IANA Considerations

This document has no IANA actions.

--- back

# Acknowledgments
{:numbered="false"}

TODO acknowledge.
